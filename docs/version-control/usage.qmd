---
title: Usage
---
## Key Principles

* Users should commit changes frequently, with descriptive messages. 
* Pull often to ensure that you are incorporating the changes of others.
* A local clone of a repository should generally ONLY have a single user.
* Take care with encoding file paths within a repository.
You want other people to be able to use the repository without having to move files around or change all the file paths in the repository.
You could either:
  * Use [relative file paths](./terminology.qmd#relative-file-paths) to point to other files that are located in the repository.
  * Use absolute file paths (i.e. on a shared network drive like the L drive) and consider making a variable for the path directory, especially if used multiple times. That way, if a collaborator has their data at a different path on their system, they only need to change a single path.
    ```
    data_path = “L:/ProjectName/Data”
    data_file_1 = joinpath(data_path, “data_file_1.csv”)
    data_file_2 = joinpath(data_path, “data_file_2.csv”)
    ```

  * If you use relative file paths pointing to files outside the repository, specify in the project README how the external files and the repository should be positioned relative to each other.

Here are two examples of how a project / team might choose to use repositories.

* Each team member keeps their own working version of a repository somewhere private, either on the `C:/` drive of their personal computer, or on the RFF servers, with the intention of no other team members having access to it.
  * __Pros__: it is “clean”, with no accidental file changes from other users.
  * __Cons__: It would require care to be taken for access to non-version-controlled data files.
* Each team member keeps their own working version of a repository on a shared drive, i.e. the L drive, which could (but probably shouldn’t) be accessed by others, i.e. inside of a larger project directory
  * __Pros__: it allows easy access to shared project files; specifically, users can see changes made by others if they haven't pushed them to the repository due to outside circumstances
  * __Cons__: files could be accidentally  changed by others if they are working in the incorrect version of the repository

## Basic Workflow

This section outlines the bare-bones workflow for using Git and GitHub.
Start here and familiarize yourself with these concepts before optionally moving onto the [Branch Workflow](#branch-workflow).
Essentially, the workflow begins with either [create a new repository](#creating-a-repository) or [clone an existing repository](#cloning-a-repository).
Then, after [editing the files](#editing-files), it is necessary to [stage the file changes](#staging-file-changes), then [commit the file changes](#commiting-file-changes), then [push the committed changes](#pushing-committed-changes) to the remote repository.
When collaborating with others, it may be necessary to [pull published commits made by others](#pulling-changes-from-others).
If both you and the collaborator have made changes, it may prove necessary to [handle any merge conflicts](#handling-merge-conflicts).  If these conflicts happen often, it may be worth considering the [branch workflow](#branch-workflow), which is better suited for frequent collaboration on the same set of files.

<TODO: add detail to the basic concepts>

#### Creating a repository
#### Cloning a repository
#### Editing files
#### Staging file changes
#### Committing file changes
#### Pushing committed changes
#### Pulling changes from others
#### Handling merge conflicts

A team could do all their software development using these basic concepts.
One person would create a repository in github, then all team members would clone the repository to make a copy on their computers.
Then, every time a team member needs to make a code change, they would first pull any changes made by other team members, then they would commit and push their changes as they make them. If another team member had pushed changes first, then one would need to pull and resolve merge conflicts prior to pushing their changes.
This workflow is great for small teams because it has very little overhead for using git.
However it is only a good choice if the team doesn’t need to make too many concurrent code changes, and doesn’t need to review each other’s code changes.
A team can always start off using this workflow, and introduce some of the more advanced concepts later on.
For sample RFF repositories using this workflow, see: <TODO: Insert link(s) here>

## Branch Workflow

In the basic workflow, we talked about the problem of concurrent changes causing conflicts.
In order to get around that process, we can use a concept called “branches”.
In the basic workflow above, we have a single branch, by default usually named “main”.
Branches allow you to create a separate version of the repository, make changes to it, then, when ready, review and merge those code changes into the main branch, or any other branch.
We’ll break down the steps below.

<TODO: add detail to the advanced concepts>

* Making a local branch
* Pushing a local branch to a remote repository
* Creating a pull request
* Reviewing a pull request
* Merging a pull request
